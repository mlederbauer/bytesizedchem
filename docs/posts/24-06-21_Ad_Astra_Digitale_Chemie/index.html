<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Magdalena Lederbauer">
<meta name="dcterms.date" content="2024-06-21">

<title>bytesizedchem - Ad Astra</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../assets/favicon.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">bytesizedchem</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mlederbauer"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/maglederb"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/magdalena-lederbauer/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Ad Astra</h1>
            <p class="subtitle lead">Der Paradigmenwechsel der Digitalen Chemie</p>
                                <div class="quarto-categories">
                <div class="quarto-category">comment</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Magdalena Lederbauer </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 21, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><em>An der jährlichen “Thanks Giving”-Veranstaltung der ETH Foundation präsentieren junge Forschende und Entrepreneurs ihre Arbeit vor den Donatoren. Ich hatte die Ehre, zur 2024 Edition eingeladen zu werden und einen Teil meiner aktuellen Forschung vorzustellen. Eine Abschrift meines Vortrags.</em></p>
<p>Guten Abend, meine Damen und Herren. Es ist mir eine große Freude, Ihnen heute einen Teil meiner <strong>Forschung und Leidenschaft</strong>, die digitale Chemie, näherzubringen.</p>
<p><img src="images/Slide1.png" class="img-fluid"> <em>Matterhorn bei Nacht. Bild von <a href="https://unsplash.com/@explorewithjoshua?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Explore with Joshua</a> auf <a href="https://unsplash.com/photos/snow-covered-mountain-under-blue-sky-during-night-time-4yBogrmcEmM?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Unsplash</a>.</em></p>
<p>Die Chemie, wie wir sie kennen, ist ein unglaublich weitläufiges Gebiet, das in <strong>jeden Bereich unseres Lebens</strong> reicht. Wir sprechen von der Entwicklung neuer Medikamente und erneuerbarer Energien bis hin zu Materialien für die Elektronik, die es mir ermöglichen, diese Präsentation vor Ihnen zu projizieren. Ebenso gibt es eine enorme Anzahl an möglichen Materialien und Molekülen, die wir herstellen können: Stellen Sie sich vor, das Universum der Chemie ist so weitläufig wie der <strong>Nachthimmel</strong> über uns. Es gibt viel mehr Sterne, als wir je zählen könnten!</p>
<p><img src="images/Slide7.png" class="img-fluid"></p>
<p>Es gibt schätzungsweise 10^60 kleine organische Moleküle, die wir theoretisch herstellen könnten. Das ist eine <strong>1 mit 60 Nullen</strong>. Das entspricht so vielen Molekülen, wie es Sandkörner auf der Erde gibt… multipliziert mit der Anzahl Planeten im bekannten Universum. Von diesen unermesslichen Möglichkeiten haben wir jedoch nur einen winzigen Bruchteil entdeckt oder hergestellt!</p>
<p><img src="images/Slide2.png" class="img-fluid"></p>
<p>Im Anbetracht gegenwärtiger globaler Herausforderungen, für deren Lösung die Chemie eine zentrale Rolle spielt, müssen einen Weg finden, die <strong>vielversprechendsten Galaxien und Sterne zu orten</strong>, um etwa den aktivsten Katalysator oder den besten chemischen Prozess zu finden - Und dafür braucht es digitale Chemie!</p>
<p><img src="images/Slide3.png" class="img-fluid"></p>
<p>Die traditionelle Chemie, wie wir sie kennen, ist oft langwierig und ressourcenintensiv. Forschende haben eine <strong>Idee</strong>, formulieren eine <strong>Hypothese</strong>, die mit einem <strong>experimentellen Setup</strong> getestet wird, man erhält ein <strong>Resultat</strong>, extrahiert die <strong>Daten</strong>. Sehr häufig werden basierend auf <strong>chemischer Intuition</strong> Annahmen getroffen, Hypothesen verfeinert, und der Loop nochmals gestartet. Und das hat uns bis dato sehr weit gebracht! Allerdings hat es sich auch herausgestellt, dass das nicht der effizienteste Weg ist, um die gesammelten Daten optimal zu nutzen…</p>
<p>Hier kommt die digitale Chemie ins Spiel – basierend auf den Entwicklungen in <strong>Algorithmen, Modellen und gesteigerter Rechenleistung</strong> nutzt sie unter anderem maschinelles Lernen, um aus einem Meer von Daten aus Labor &amp; Literatur schnell und effizient neue Erkenntnisse zu gewinnen und chemische Probleme zu lösen.</p>
<p><img src="images/Slide4.png" class="img-fluid"></p>
<p>Eine Art, diese künstliche Intelligenz einzusetzen, sind Sprachmodelle, auch Large Language Models genannt. Bekannt wurden sie insbesondere durch Modelle wie ChatGPT, die in den letzten eineinhalb Jahren global Aufmerksamkeit erregt haben. Diese Modelle halten nicht nur in Chats Einzug, sondern auch in den Naturwissenschaften und Ingenieurwissenschaften.</p>
<p>Man kann die Chemie nämlich als Sprache verstehen! Im weitesten Sinne verarbeiten und generieren Sprachmodelle Text, beispielsweise in der Übersetzung von Texten, oben gezeigt vom Französischen ins Deutsche. In der Chemie, also hier auf Moleküle umgemünzt, kann man Sprachmodelle darauf trainieren, die Ausgangsstoffe in Produkte zu übersetzen, die Reaktionsprodukte vorherzusagen.</p>
<p>Ein Atom ist wie ein Buchstabe, ein Molekül wie ein Wort, und eine Reaktion wie ein ganzer Satz. Der Input sind die Ausgangsmaterialien, oder die Anfrage, eines Users, der Output die Produkte. Diese Modelle wurden auf einem gigantischen Korpus and Text- und chemischen Daten trainiert und ermöglichen es uns so, auf neue Daten zu extrapolieren und neue Moleküle zu finden.</p>
<p><img src="images/Slide5.png" class="img-fluid"></p>
<p>Auch in meiner aktuellen Forschung arbeite ich am Einsatz von Sprachmodellen für die Entwicklung von Katalysatoren zur Fixierung von Kohlenstoffdioxid, also CO2. Mit Hilfe von effizienten Katalysatoren könnten wir CO2 aus unserer Luft in wertvolle Chemikalien, die wir für unseren Alltag benötigen, und Treibstoffe umwandeln; Etwas, was für die Erstellung einer Kreislaufwirtschaft unerlässlich ist.</p>
<p>Es gibt eine Klasse von atomaren Katalysatoren (Single Atom Catalysts), die aus ausgeklügelten Kombinationen von Metallen, Trägermaterialien und Liganden besteht. Neue solche Katalysatoren zu entdecken ist eine kombinatorische Herausforderung!</p>
<p>Wir machen uns hier die Tatsache zunutze, dass bereits mehrere Jahrzehnte lang umfangreiche Daten in Form von wissenschaftlichen Publikationen gesammelt wurden. Mit Hilfe eines Sprachmodells durchforsten wir mehrere tausend davon – mehr, als ein Mensch je lesen könnte – und extrahieren Informationen.</p>
<p>Unser Input (siehe Loop oben) ist in diesem Fall die Anfrage, einen Katalysator mit bestimmten Eigenschaften herstellen zu wollen. Beispielsweise möchten wir billigere und häufiger vorkommende Metalle verwenden, ein bestimmtes Trägermaterial oder möglichst milde Reaktionsbedingungen. Zusätzlich wird das Modell mit einem riesigen Korpus an Literatur gefüttert. Der Output ist ein Rezept (Synthesevorschrift) zur Herstellung eines solchen Katalysators.</p>
<p>Dieses Kochrezept geben wir experimentellen Kollaboratoren an der ETH Zürich, die das Experiment durchführen und uns Daten zukommen lassen, mit denen wir das Sprachmodell füttern. Mit Optimierungsalgorithmen finden wir den nächstbesseren Katalysator, wodurch wir die Anzahl der notwendigen Schritte minimieren und die iterativ die Effizienz des Prozesses steigern.</p>
<p><img src="images/Slide6.png" class="img-fluid"></p>
<p>Eine zentrale, wenn nicht die größte <strong>Herausforderung</strong> unserer Forschung ist die Evaluation der Modelle auf Verlässlichkeit und ihre <strong>Generalisierbarkeit auf unbekannte Probleme</strong>. Jeder, der ChatGPT bereits verwendet hat, weiß, dass ein Sprachmodell immer eine Antwort gibt, die überzeugend klingt. Die Frage ist nur, wie sehr können wir diesem Output trauen? Können diese Modelle verlässliche <strong>wissenschaftliche Tools</strong> sein? Wie können wir sicher sein, dass die Vorschläge nicht nur theoretisch, sondern auch praktisch sinnvoll sind? Um diesen Aspekt anzugehen, arbeite ich momentan an einem <strong>Goldstandard</strong> (<em>Benchmark</em>), einem Datensatz, der dazu verwendet wird, die Schwachstellen dieser Sprachmodelle zu erkennen. Es ist entscheidend, das Potenzial, aber auch die Risiken dieser Technologien zu erkennen und verantwortungsvoll zu handhaben.</p>
<p>Ich habe Ihnen einen kleinen Einblick in meine Forschung gegeben, die symbolhaft dafür steht, wie digitale Chemie dazu eingesetzt werden kann, Entwicklungsprozesse zu optimieren. Sie birgt das Potential, dieses <strong>gigantische Universum der Chemikalien</strong> zielstrebig zu erkunden! Das ist wichtig, um kostengünstige und nachhaltige Materialien zu entdecken. Das Feld steht für eine <strong>Synergie an Disziplinen</strong>, zwischen Expertenwissen, Algorithmen, Daten.</p>
<p>Ich freue mich darauf, diese bereichernde Arbeit fortzusetzen und danke meinen Kollaboratoren sowie Ihnen für die Förderung durch das Exzellenzstipendium (ESOP Excellence Scholarship). In diesem Sinne: <em>Ad Astra</em>!</p>
<p><img src="images/ETH_ThanksGiving24_75.jpeg" class="img-fluid"></p>
<p><em>Photo Credits to ETH Foundation / Alessandro Della Bella. Special thanks to all my collaborators inside and outside ETH Zurich: Kjell Jorner (ETHZ), Stefan Schmid (ETHZ), Vignesh Somnath (ETHZ), Antonio Togni (ETHZ), Zachariah J. Berkson (University of Arizona), Christophe Copéret (ETHZ), Benedikt Winter (ETHZ), André Bardow (ETHZ), Manu Suvarna (ETHZ), Javier Pérez-Ramírez (ETHZ), Andres M Bran (EPFL), Geemi Wellawatte (EPFL), Anna Borisova (EPFL), Bojana Rankovic (EPFL), Philippe Schwaller (EPFL).</em></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Klicken Sie <a href="https://bytesizedchem.substack.com/subscribe">hier</a>, um Updates über neue Beiträge zu erhalten.</p>
</div>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>